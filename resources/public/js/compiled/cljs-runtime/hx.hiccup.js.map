{"version":3,"sources":["hx/hiccup.cljc"],"mappings":"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","names":["hx$hiccup$IElement$_as_element$dyn","x__4428__auto__","m__4429__auto__","hx.hiccup/-as-element","goog/typeOf","m__4426__auto__","cljs.core/missing-protocol","hx.hiccup/IElement","el","config","js/hx","js/hx.hiccup","js/hx.hiccup.tag-registry","hx.hiccup/tag-registry","cljs.core.atom","hx.hiccup/extend-tag","tag","impl","cljs.core.swap_BANG_","cljs.core/assoc","hx.hiccup/tag->impl","temp__5733__auto__","t","cljs.core/deref","cljs.core.get","cljs.core/name","hx.hiccup/parse-tag","cljs.core/Keyword","cljs.core/var?","args","cljs.core.apply","hx.hiccup/make-element","fexpr__55408","hx.hiccup/parse","hiccup","cljs.core.nth","cljs.core/rest","hx.hiccup/ex","s","js/Error","goog.object/set","cljs.core/PROTOCOL_SENTINEL","_","n","cljs.core/PersistentVector","form","cljs.core/LazySeq","a","cljs.core/cons","p1__55409#","cljs.core.map","p1__55410#","fexpr__55411","cljs.core.pr_str","cljs.core/type"],"sourcesContent":["(ns hx.hiccup\n  (:require [clojure.walk :as walk]\n            [hx.utils :as util :include-macros true]))\n\n(defprotocol IElement\n  (-as-element [el config] \"Converts to an element\"))\n\n;; (declare -as-element)\n\n(defonce tag-registry (atom {}))\n\n(defn extend-tag [tag impl]\n  (swap! tag-registry assoc tag impl))\n\n(defn tag->impl [tag]\n  (if-let [t (get @tag-registry tag nil)]\n    t\n    (name tag)))\n\n;; ;; we use a multimethod to dispatch on identity so that consumers\n;; ;; can override this for custom values e.g. :<> for React fragments\n;; (defmulti extend-tag\n;;   identity\n;;   :default ::default)\n\n;; ;; if no multimethod for specific el, then apply general parsing rules\n;; (defmethod extend-tag\n;;   ::default\n;;   ([el]\n;;    (name el)))\n\n(defn parse-tag [el]\n  (cond\n    ^boolean (keyword? el) (tag->impl el)\n    ^boolean (var? el) (fn VarEl [& args] (apply el args))\n    true el))\n\n(defn make-element [config el args]\n  (util/measure-perf\n   \"make_element\"\n   ((:create-element config) config el args)))\n\n(defn parse [config hiccup]\n  (util/measure-perf\n   \"parse\"\n   (make-element config (parse-tag (nth hiccup 0)) (rest hiccup))))\n\n#?(:clj (defn array? [x]\n          (coll? x)))\n\n(defn ex [s]\n  #?(:clj (Exception. s)\n     :cljs (js/Error. s)))\n\n(extend-protocol IElement\n  nil\n  (-as-element [_ _]\n    (util/measure-perf\n     \"-as_element_nil\"\n     nil))\n\n  #?(:clj Number\n     :cljs number)\n  (-as-element [n _]\n    (util/measure-perf\n     \"-as_element_number\"\n     n))\n\n  #?(:clj String\n     :cljs string)\n  (-as-element [s _]\n    (util/measure-perf\n     \"-as_element_string\"\n     s))\n\n  #?(:clj clojure.lang.PersistentVector\n     :cljs PersistentVector)\n  (-as-element [form config]\n    (util/measure-perf\n     \"-as_element_vector\"\n     (make-element config (parse-tag (nth form 0)) (rest form))))\n\n  #?(:clj clojure.lang.LazySeq\n     :cljs LazySeq)\n  (-as-element [a config]\n    (util/measure-perf\n     \"-as_element_lazyseq\"\n     (make-element\n      config\n      (:fragment config)\n      (cons nil (map #(-as-element % config) a)))))\n\n  #?(:cljs array)\n  #?(:cljs (-as-element [a config]\n                        (util/measure-perf\n                         \"-as_element_array\"\n                         (make-element\n                          config\n                          (:fragment config)\n                          (cons nil (map #(-as-element % config) a))))))\n\n  #?(:clj Object\n     :cljs default)\n  (-as-element [el config]\n    (cond\n      ((:is-element? config) el) el\n\n      :default\n      (throw\n       (ex (str \"Unknown element type \" (pr-str (type el))\n                \" found while parsing hiccup form: \"\n                (.toString el)))))))\n"]}