{"version":3,"sources":["checkers/ai.cljs"],"mappings":"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","names":["checkers.ai/+infinity","checkers.ai/-infinity","checkers.ai/pawn_pos_score","db","cljs.core.apply","cljs.core/+","cljs.core.into","iter__4529__auto__","s__55879","cljs.core/LazySeq","temp__5735__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4527__auto__","size__4528__auto__","cljs.core/count","b__55881","cljs.core/chunk-buffer","i__55880","vec__55882","cljs.core/-nth","cljs.core.nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__55878","cljs.core/chunk-rest","vec__55885","cljs.core/first","cljs.core/cons","cljs.core/rest","k","v","cljs.core._EQ_","checkers.ai/eval_score","cofx","score","checkers.ai/minimax","depth","player","moves","checkers.helpers/all_possible_moves_or_only_captures","scores","cljs.core.map","move","G__55888","G__55889","checkers.handlers/execute_move","cljs.core/max","cljs.core/min","checkers.ai/minimax_reduce","alphaInit","betaInit","searchInitializer","compOperator","cljs.core.reduce","p__55890","vec__55891","alpha","beta","best","vec__55894","movedDb","moveType","newBest","G__55897","G__55898","G__55899","G__55900","G__55901","G__55902","newAlpha","newBeta","x__4214__auto__","y__4215__auto__","x__4217__auto__","y__4218__auto__","cljs.core/reduced","checkers.ai/get_best_move_minmax","color","turn","moves_scores","cljs.core/max-key","cljs.core/min-key","cljs.core/chunk-first"],"sourcesContent":["(ns checkers.ai\n  (:require\n   [re-frame.core :as re-frame]\n   [checkers.db :as db]\n   [clojure.set :as set]\n   [checkers.helpers :as helpers]\n   [checkers.handlers :as handlers]))\n\n\n(def  +infinity 9999999999)\n(def  -infinity -9999999999)\n\n(defn pawn_pos_score [db]\n  (apply + (into () (for [[k v] (:board db)]\n                      (cond\n                        (= v {:color \"b\" :name \"p\"}) (* -1 (* (k 0) (k 0)))\n                        (= v {:color \"w\" :name \"p\"}) (* (- 7 (k 0)) (- 7 (k 0)))\n                        :else 0)))))\n(defn eval_score [cofx]\n  (let [db (:db cofx)\n        score (:score db)]\n    ;(js/console.log (prn-str \"eval_score db \" db))\n    (+ \n     (* 1000 (- (score 0) (score 1)))\n     (pawn_pos_score db))\n    ))\n\n(defn minimax [cofx depth]\n  (let [db (:db cofx)\n        player (:turn db)\n        moves (helpers/all_possible_moves_or_only_captures db)]\n    (if (= 0 depth)\n      (eval_score cofx)\n      (let [scores (map (fn [move]  (minimax \n                                     (handlers/execute_move cofx move)\n                                     (dec depth))) \n                        moves\n                        )]\n        ;(js/console.log (prn-str \"best move minimax scores : \" moves))\n        (if (= player \"w\")\n          (apply max scores)\n          (apply min scores))))\n    ))\n\n(defn minimax_reduce [cofx depth alphaInit betaInit]\n  (let [db (:db cofx)\n        player (:turn db)\n        moves (helpers/all_possible_moves_or_only_captures db)\n        searchInitializer (if (= player \"w\") -infinity +infinity)\n        compOperator (if (= player \"w\") max min)]\n        (if (= 0 depth)\n          (eval_score cofx)\n          (let [score\n                (reduce (fn [[alpha beta best] move ]\n                          (let [movedDb (handlers/execute_move cofx move)\n                                moveType   (:last_move movedDb)\n                                newBest (compOperator \n                                         best\n                                         (minimax_reduce\n                                          movedDb\n                                          (if  (= moveType :capture) depth (dec depth)) \n                                          alpha beta))\n\n                                [newAlpha newBeta] (if (= player \"w\")\n                                                     [(max newBest alpha) beta]\n                                                     [alpha (min newBest beta)])]\n                            ;(when (<= beta alpha) (js/console.log (prn-str \"alpha \" alpha \" beta \" beta \" pruning\")))\n                            (if (<= beta alpha)\n                             (reduced [newAlpha newBeta newBest]) \n                              [newAlpha newBeta newBest]\n                              )\n                            ))\n                        [alphaInit betaInit searchInitializer] \n                        moves)]\n            ;(js/console.log (prn-str score))\n            (score 2)\n            )\n\n          )))\n(defn get_best_move_minmax [cofx color depth] \n  (let [db (:db cofx)\n        turn (:turn db)\n        moves (helpers/all_possible_moves_or_only_captures db)\n        moves_scores (map (fn [move] {:move move\n                                      :score  (minimax_reduce\n                                               (handlers/execute_move cofx move )\n                                               depth -infinity +infinity)})\n                    moves)]\n    ;(js/console.log (prn-str \"best move minimax moves : \" moves))\n    (if (= turn color)\n      (if (= color \"w\")\n        (:move (apply max-key :score moves_scores))\n        (:move (apply min-key :score moves_scores)))\n      nil)))\n"]}